#+PROPERTY: header-args:emacs-lisp :tangle (concat temporary-file-directory "緑衣.el") :lexical t
#+title: 緑衣

#+begin_verse
  國風・邶風・緑衣

  緑兮衣兮、緑衣黃裹
  心之憂矣、曷維其已

  緑兮衣兮、緑衣黃裳
  心之憂矣、曷維其亡

  緑兮絲兮、女所治兮
  我恖古人、俾無訧兮

  絺兮綌兮、淒其以風
  我恖古人、實獲我心
#+end_verse

永不弃者載入于初始之旹也

Permanent configuration file.

You cannot disable anything here.

* 題                                                           :noexport:

#+begin_src emacs-lisp :exports none
  ;;; 緑衣.el --- Nasy's emacs.d permanent file.  -*- lexical-binding: t; -*-

  ;; Copyright (C) 2021  Nasy

  ;; Author: Nasy <nasyxx@gmail.com>

  ;;; Commentary:

  ;; 永不弃者載入于初始之旹也

  ;;; Code:

  (cl-eval-when (compile)
    (setq nasy--require t)
    (add-to-list 'load-path (locate-user-emacs-file  "桃夭/擊鼓" ))
    (add-to-list 'load-path (locate-user-emacs-file  "桃夭/風雨" ))
    (require '擊鼓)
    (require '風雨)
    (require '風雨旹用)

    (require 'ffap)
    (require 'winner)

    (sup 'alert)
    (sup 'embark)
    (sup 'selectrum)
    (sup 'transient)
    (sup 'which-key)
    (setq nasy--require nil))

#+end_src

* 章

** Anzu                                                   :search:tools:

anzu.el is an Emacs port of anzu.vim. anzu.el provides a minor mode which
displays current match and total matches information in the mode-line in various
search modes.

https://github.com/emacsorphanage/anzu

#+begin_src emacs-lisp
  (n/leaf-nv anzu
    :doc "anzu.el is an Emacs port of anzu.vim."
    :url "https://github.com/emacsorphanage/anzu"
    :tag "search" "tools"
    :leaf-autoload nil
    :leaf-defun nil
    :hook ((nasy-first-key-hook . global-anzu-mode))
    :bind (([remap query-replace]        . anzu-query-replace)
           ([remap query-replace-regexp] . anzu-query-replace-regexp))
    :init (sup 'anzu))
#+end_src

** Avy                                                  :point:location:

Jump to things in Emacs tree-style.

https://github.com/abo-abo/avy

#+begin_src emacs-lisp
  (n/leaf-nv avy
    :doc "Jump to things in Emacs tree-style."
    :url "https://github.com/abo-abo/avy"
    :tag "point" "location"
    :leaf-autoload nil
    :leaf-defun nil
    :custom
    (avy-keys . '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s)) ;; for dvorak
    :bind
    ("C-:"     . avy-goto-char)
    ;; ("C-'"     . avy-goto-char-2)
    ;; ("C-`"     . avy-goto-char-2)
    ("M-g e"   . avy-goto-word-0)
    ("M-g w"   . avy-goto-word-1)
    ;; ("C-~"     . avy-goto-word-1)
    ("C-c C-j" . avy-resume)
    :init (sup 'avy))
#+end_src

** Beginend                                                    :editing:

Emacs package to redefine M-< and M-> for some modes

https://github.com/DamienCassou/beginend

#+begin_src emacs-lisp
  (n/leaf-nv beginend
    :doc "Emacs package to redefine M-< and M-> for some modes"
    :url "https://github.com/DamienCassou/beginend"
    :tag "editing"
    :leaf-autoload nil
    :leaf-defun nil
    :hook ((emacs-startup-hook . beginend-global-mode))
    :init (sup 'beginend))
#+end_src

** Company                                          :editing:extensions:

*** Autoloads
:PROPERTIES:
:header-args:emacs-lisp: :tangle (concat temporary-file-directory "nasy-company.el") :lexical t
:END:

#+begin_src emacs-lisp
  ;;; nasy-company.el --- Nasy's emacs.d company functions file.  -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;; Company Functions

  ;;; Code:

  (require '擊鼓)
  (require '風雨)
  (require '風雨旹用)

  (require 'whitespace)

  (require 'company)
  (require 'company-dabbrev)
  (require 'company-dabbrev-code)

  ;;;###autoload
  (defvar nasy/company-backend-alist
    '((text-mode company-dabbrev company-yasnippet company-ispell company-files)
      (prog-mode company-capf company-yasnippet company-files)
      (conf-mode company-capf company-dabbrev-code company-yasnippet company-files))
    "An alist matching modes to company backends.

  The backends for any mode is built from this.")


  ;;;###autoload
  (defun nasy/add-company-backend (modes &rest backends)
    "Prepend BACKENDS (in order) to `company-backends' in MODES.

  MODES should be one symbol or a list of them, representing major or minor modes.
  This will overwrite backends for MODES on consecutive uses.

  If the car of BACKENDS is nil, unset the backends for MODES.
  Examples:
   (nasy/add-company-backend 'js2-mode
     'company-tide 'company-yasnippet)
   (nasy/add-company-backend 'sh-mode
     '(company-shell :with company-yasnippet))
   (nasy/add-company-backend '(c-mode c++-mode)
     '(:separate company-irony-c-headers company-irony))
   (nasy/add-company-backend 'sh-mode nil)  ; unsets backends for `sh-mode'"

    (declare (indent defun))
    (dolist (mode (nasy/enlist modes))
      (if (null (car backends))
          (setq nasy/company-backend-alist
                (delq (assq mode nasy/company-backend-alist)
                      nasy/company-backend-alist))
        (setf (alist-get mode nasy/company-backend-alist)
              backends))))


  ;;;###autoload
  (defun nasy/company-backends ()
    "Get company backends."
    (let (backends)
      (let ((mode major-mode)
            (modes (list major-mode)))
        (while (setq mode (get mode 'derived-mode-parent))
          (push mode modes))
        (dolist (mode modes)
          (dolist (backend (append (cdr (assq mode nasy/company-backend-alist))
                                   (default-value 'company-backends)))
            (push backend backends)))
        (delete-dups
         (append (cl-loop for (mode . backends) in nasy/company-backend-alist
                          if (or (eq major-mode mode)  ; major modes
                                (and (boundp mode)
                                   (symbol-value mode))) ; minor modes
                          append backends)
                 (nreverse backends))))))


  ;;;###autoload
  (defun nasy/company-init-backends-h ()
    "Set `company-backends' for the current buffer."
    (or (memq major-mode '(fundamental-mode special-mode))
       buffer-read-only
       (nasy/temp-buffer-p (or (buffer-base-buffer) (current-buffer)))
       (setq-local company-backends (nasy/company-backends))))


  (put 'nasy/company-init-backends-h 'permanent-local-hook t)


  ;;;###autoload
  (defun nasy/company-complete ()
    "Bring up the completion popup.  If only one result, complete it."
    (interactive)
    (require 'company)
    (when (ignore-errors
            (/= (point)
                (cdr (bounds-of-thing-at-point 'symbol))))
      (save-excursion (insert " ")))
    (when (and (company-manual-begin)
               (= company-candidates-length 1))
      (company-complete-common)))


  ;;;###autoload
  (defun nasy/company-has-completion-p ()
    "Return non-nil if a completion candidate exists at point."
    (and (company-manual-begin)
         (= company-candidates-length 1)))


  ;;;###autoload
  (defun nasy/company-toggle-auto-completion ()
    "Toggle as-you-type code completion."
    (interactive)
    (require 'company)
    (setq company-idle-delay (unless company-idle-delay 0.2))
    (message "Auto completion %s"
             (if company-idle-delay "enabled" "disabled")))


  ;;;###autoload
  (defun nasy/company-dabbrev ()
    "Invokes `company-dabbrev-code' in `prog-mode' buffers and `company-dabbrev' everywhere else."
    (interactive)
    (call-interactively
     (if (derived-mode-p 'prog-mode)
         #'company-dabbrev-code
       #'company-dabbrev)))


  ;;;###autoload
  (defun nasy/company-whole-lines (command &optional arg &rest ignored)
    "`company-mode' completion backend that completes whole-lines, akin to vim's
        C-x C-l."
    (interactive (list 'interactive))
    (require 'company)
    (pcase command
      (`interactive (company-begin-backend 'nasy/company-whole-lines))
      (`prefix      (company-grab-line "^[\t\s]*\\(.+\\)" 1))
      (`candidates
       (all-completions
        arg
        (delete-dups
         (split-string
          (replace-regexp-in-string
           "^[\t\s]+" ""
           (concat (buffer-substring-no-properties (point-min) (line-beginning-position))
                   (buffer-substring-no-properties (line-end-position) (point-max))))
          "\\(\r\n\\|[\n\r]\\)" t))))))


  ;;;###autoload
  (defun nasy/company-dict-or-keywords ()
    "`company-mode' completion combining `company-dict' and `company-keywords'."
    (interactive)
    (require 'company-dict)
    (require 'company-keywords)
    (let ((company-backends '((company-keywords company-dict))))
      (call-interactively #'company-complete)))


  ;;;###autoload
  (defun nasy/company-dabbrev-code-previous ()
    "TODO."
    (interactive)
    (require 'company-dabbrev)
    (let ((company-selection-wrap-around t))
      (call-interactively #'nasy/company-dabbrev)
      (company-select-previous-or-abort)))


  ;;;###autoload
  (defvar nasy/prev-whitespace-mode nil)
  (make-variable-buffer-local 'nasy/prev-whitespace-mode)


  ;;;###autoload
  (defvar nasy/show-trailing-whitespace nil)
  (make-variable-buffer-local 'nasy/show-trailing-whitespace)


  (defvar my-prev-whitespace-mode nil)

  ;;;###autoload
  (defun nasy/-pre-popup-draw ()
    "Turn off whitespace mode before showing company complete tooltip."
    (if whitespace-mode
        (progn
          (setq my-prev-whitespace-mode t)
          (whitespace-mode -1)))
    (setq nasy/show-trailing-whitespace show-trailing-whitespace)
    (setq show-trailing-whitespace nil))


  ;;;###autoload
  (defun nasy/-post-popup-draw ()
    "Restore previous whitespace mode after showing company tooltip."
    (if nasy/prev-whitespace-mode
        (progn
          (whitespace-mode 1)
          (setq nasy/prev-whitespace-mode nil)))
    (setq show-trailing-whitespace nasy/show-trailing-whitespace))


  ;;;###autoload
  (defun nasy/company-filter-c ()
    (company-search-abort)
    (company-filter-candidates))



  ;;;###autoload
  (defun nasy/company-box-icons--elisp-fn (candidate)
    (when (derived-mode-p 'emacs-lisp-mode)
      (let ((sym (intern candidate)))
        (cond ((fboundp  sym) 'ElispFunction)
              ((boundp   sym) 'ElispVariable)
              ((featurep sym) 'ElispFeature)
              ((facep    sym) 'ElispFace)))))


  ;;;###autoload
  (defun nasy/company-remove-scrollbar-a (orig-fn &rest args)
    "This disables the company-box scrollbar, because:
    https://github.com/sebastiencs/company-box/issues/44"
    (cl-letf (((symbol-function #'display-buffer-in-side-window)
               (symbol-function #'ignore)))
      (apply orig-fn args)))


  (provide 'nasy-company)
  ;;; nasy-company.el ends here
#+end_src

*** company

#+begin_src emacs-lisp
  (leaf nasy-company
    :load-path* "桃夭/緑衣"
    :commands
    (nasy/add-company-backend
     nasy/company-backends
     nasy/company-init-backends-h
     nasy/company-complete
     nasy/company-has-completion-p
     nasy/company-toggle-auto-completion
     nasy/company-dabbrev
     nasy/company-whole-lines
     nasy/company-dict-or-keywords
     nasy/company-dabbrev-code-previous
     nasy/-pre-popup-draw
     nasy/-post-popup-draw
     nasy/company-filter-c
     nasy/company-box-icons--elisp-fn
     nasy/company-remove-scrollbar-a))

  (n/leaf-nv company
    :leaf-autoload nil
    :leaf-defun nil
    :hook (prog-mode-hook org-mode-hook)
    :bind
    ("C-;"     . nasy/company-complete)
    ("M-/"     . company-files)
    ("C-<tab>" . nasy/company-complete)
    ([remap indent-for-tab-command]
     . company-indent-or-complete-common)
    (:company-mode-map
     ([remap indent-for-tab-command]
      . company-indent-or-complete-common)
     ("M-/" . company-files))
    (:company-active-map
     ("C-o"        . company-search-kill-others)
     ("C-n"        . company-select-next)
     ("C-p"        . company-select-previous)
     ("C-h"        . company-quickhelp-manual-begin)
     ("C-S-h"      . company-show-doc-buffer)
     ("C-s"        . company-search-candidates)
     ("M-s"        . company-filter-candidates)
     ([C-tab]      . nasy/company-complete)
     ([tab]        . company-complete-common-or-cycle)
     ([backtab]    . company-select-previous))
    (:company-search-map
     ("C-n"        . company-search-repeat-forward)
     ("C-p"        . company-search-repeat-backward)
     ("C-s"        . nasy/company-filter-c))
    :custom
    ((company-tooltip-limit       . 10)
     (company-dabbrev-downcase    . nil)
     (company-dabbrev-ignore-case . t)
     (company-global-modes
      . '(not erc-mode message-mode help-mode gud-mode eshell-mode))
     ;; `(company-frontends
     ;;   . ,(if *c-box*
     ;;          '(company-box-frontend)
     ;;        '(company-pseudo-tooltip-frontend company-echo-metadata-frontend)))
     (company-dabbrev-other-buffers     . 'all)
     (company-tooltip-align-annotations . t)
     (company-minimum-prefix-length     . 2)
     (company-idle-delay                . 1)
     (company-tooltip-idle-delay        . .2)
     (company-require-match             . 'never)
     (company-format-margin-function    . #'company-vscode-dark-icons-margin))
    :init (sup 'company)
    :config
    (add-hook 'after-change-major-mode-hook #'nasy/company-init-backends-h 'append)
    :defer-config
    (add-to-list 'completion-styles 'initials t)
    (setq company-backends '(company-capf))
    :advice
    (:before company-pseudo-tooltip-unhide nasy/-pre-popup-draw)
    (:after  company-pseudo-tooltip-hide   nasy/-post-popup-draw))
#+end_src

*** Company Quickhelp

#+begin_src emacs-lisp
  (n/leaf company-quickhelp
    :leaf-autoload nil
    :leaf-defun nil
    :after company
    :bind
    (:company-active-map
     ("C-c h" . company-quickhelp-manual-begin))
    :hook company-mode-hook
    :custom
    (pos-tip-use-relative-coordinates . t)
    :init (sup 'company-quickhelp))
#+end_src

*** Company Tabnine

#+begin_src emacs-lisp
  (n/leaf-nv company-tabnine
    :leaf-autoload nil
    :leaf-defun nil
    :after company
    :custom
    `(company-tabnine-binaries-folder . ,(concat *nasy-var* "company/tabnine-binaries"))
    `(company-tabnine-log-file-path
      . ,(concat *nasy-var* "company/tabnine-binaries/log"))
    :init (sup 'company-tabnine))
#+end_src

*** Company Flx

#+begin_src emacs-lisp
  (n/leaf-nv company-flx
    :leaf-autoload nil
    :leaf-defun nil
    :after company
    :hook company-mode-hook
    :init (sup 'company-flx))
#+end_src

*** Company Box

#+begin_src emacs-lisp
  (n/leaf-nv company-box
    :leaf-autoload nil
    :leaf-defun nil
    :after company
    :hook company-mode-hook
    :custom
    (company-box-show-single-candidate . t)
    (company-box-max-candidates        . 25)
    (company-box-icons-alist           . 'company-box-icons-all-the-icons)
    :init
    (sup 'company-box)
    :config
    (setq
     company-box-icons-functions
     (cons #'nasy/company-box-icons--elisp-fn
           (delq 'company-box-icons--elisp
                 company-box-icons-functions)))

    (after-x 'all-the-icons
      (setq
       company-box-icons-all-the-icons
       (let ((all-the-icons-scale-factor 0.8))
         `((Unknown       . ,(all-the-icons-material "find_in_page"             :face 'all-the-icons-purple))
           (Text          . ,(all-the-icons-material "text_fields"              :face 'all-the-icons-green))
           (Method        . ,(all-the-icons-material "functions"                :face 'all-the-icons-yellow))
           (Function      . ,(all-the-icons-material "functions"                :face 'all-the-icons-yellow))
           (Constructor   . ,(all-the-icons-material "functions"                :face 'all-the-icons-yellow))
           (Field         . ,(all-the-icons-material "functions"                :face 'all-the-icons-yellow))
           (Variable      . ,(all-the-icons-material "adjust"                   :face 'all-the-icons-blue))
           (Class         . ,(all-the-icons-material "class"                    :face 'all-the-icons-cyan))
           (Interface     . ,(all-the-icons-material "settings_input_component" :face 'all-the-icons-cyan))
           (Module        . ,(all-the-icons-material "view_module"              :face 'all-the-icons-cyan))
           (Property      . ,(all-the-icons-material "settings"                 :face 'all-the-icons-lorange))
           (Unit          . ,(all-the-icons-material "straighten"               :face 'all-the-icons-red))
           (Value         . ,(all-the-icons-material "filter_1"                 :face 'all-the-icons-red))
           (Enum          . ,(all-the-icons-material "plus_one"                 :face 'all-the-icons-lorange))
           (Keyword       . ,(all-the-icons-material "filter_center_focus"      :face 'all-the-icons-lgreen))
           (Snippet       . ,(all-the-icons-material "short_text"               :face 'all-the-icons-lblue))
           (Color         . ,(all-the-icons-material "color_lens"               :face 'all-the-icons-green))
           (File          . ,(all-the-icons-material "insert_drive_file"        :face 'all-the-icons-green))
           (Reference     . ,(all-the-icons-material "collections_bookmark"     :face 'all-the-icons-silver))
           (Folder        . ,(all-the-icons-material "folder"                   :face 'all-the-icons-green))
           (EnumMember    . ,(all-the-icons-material "people"                   :face 'all-the-icons-lorange))
           (Constant      . ,(all-the-icons-material "pause_circle_filled"      :face 'all-the-icons-blue))
           (Struct        . ,(all-the-icons-material "streetview"               :face 'all-the-icons-blue))
           (Event         . ,(all-the-icons-material "event"                    :face 'all-the-icons-yellow))
           (Operator      . ,(all-the-icons-material "control_point"            :face 'all-the-icons-red))
           (TypeParameter . ,(all-the-icons-material "class"                    :face 'all-the-icons-red))
           (Template      . ,(all-the-icons-material "short_text"               :face 'all-the-icons-green))
           (ElispFunction . ,(all-the-icons-material "functions"                :face 'all-the-icons-red))
           (ElispVariable . ,(all-the-icons-material "check_circle"             :face 'all-the-icons-blue))
           (ElispFeature  . ,(all-the-icons-material "stars"                    :face 'all-the-icons-orange))
           (ElispFace     . ,(all-the-icons-material "format_paint"             :face 'all-the-icons-pink))))))

    :advice (:around
             company-box--update-scrollbar
             nasy/company-remove-scrollbar-a))
#+end_src

** Compile                                                     :builtin:

#+begin_src emacs-lisp
  (n/leaf-nv compile
    :tag "builtin"
    :leaf-autoload nil
    :advice (:after compilation-start nasy/save-compilation-buffer)
    :bind (([f6] . recompile))
    :hook ((compilation-finish-functions . alert-after-compilation-finish))
    :init
    (defvar nasy/last-compilation-buffer nil
      "The last buffer in which compilation took place.")

    (defun nasy/save-compilation-buffer (&rest _)
      "Save the compilation buffer to find it later."
      (setq nasy/last-compilation-buffer next-error-last-buffer))

    (defun alert-after-compilation-finish (buf result)
      "Use `alert' to report compilation RESULT if BUF is hidden."
      (when (buffer-live-p buf)
        (unless (catch 'is-visible
                  (walk-windows (lambda (w)
                                  (when (eq (window-buffer w) buf)
                                    (throw 'is-visible t))))
                  nil)
          (alert (concat "Compilation " result)
                 :buffer buf
                 :category 'compilation)))))
#+end_src

** Consult                                                  :extensions:

consult.el - Consulting completing-read.

https://github.com/minad/consult

Include consult, consult-selectrum & consult-flycheck.

*** consult

#+begin_src emacs-lisp
  (n/leaf-nr consult
    :doc "consult.el - Consulting completing-read"
    :url "https://github.com/minad/consult"
    :tag "extensions"
    :leaf-autoload nil
    :leaf-defun nil
    :after selectrum
    :require t recentf
    :custom
    `(consult-narrow-key . ,(kbd "C-."))
    :bind
    (([remap switch-to-buffer]              . consult-buffer)
     ([remap switch-to-buffer-other-window] . consult-buffer-other-window)
     ([remap switch-to-buffer-other-frame]  . consult-buffer-other-frame))

    (([remap apropos]            . consult-apropos)
     ([remap bookmark-jump]      . consult-bookmark)
     ([remap goto-line]          . consult-goto-line)
     ([remap imenu]              . consult-imenu)
     ([remap multi-occur]        . consult-multi-occur)
     ([remap recentf-open-files] . consult-recent-file)
     ([remap yank-pop]           . consult-yank-replace))

    (("C-s"   . consult-line)
     ("C-S-s" . nasy/consult-line-symbol-at-point))
    :init (sup 'consult)
    :defer-config
    (consult-customize
     consult-ripgrep consult-git-grep consult-grep consult-bookmark consult-recent-file
     consult--source-file consult--source-project-file consult--source-bookmark
     consult-buffer
     :preview-key (kbd "M-."))
    (defun nasy/consult-line-symbol-at-point ()
      (interactive)
      (consult-line (thing-at-point 'symbol))))
#+end_src

*** consult-selectrum

#+begin_src emacs-lisp
  (n/leaf-nr consult-selectrum
    :doc "consult.el - Consulting completing-read"
    :url "https://github.com/minad/consult"
    :tag "extensions"
    :after consult selectrum
    :require t)
#+end_src

*** consult-flycheck

#+begin_src emacs-lisp
  (n/leaf-nv consult-flycheck
    :doc "consult.el - Consulting completing-read"
    :url "https://github.com/minad/consult"
    :tag "extensions"
    :leaf-autoload nil
    :leaf-defun nil
    :after consult
    :bind (:flycheck-command-map
           ("!" . consult-flycheck))
    :init (sup 'consult-flycheck))
#+end_src

*** consult-dir                                           :convenience:

Consult-dir allows you to easily select and switch between “active”
directories.

https://github.com/karthink/consult-dir

#+begin_src emacs-lisp
  (n/leaf-nv consult-dir
    :doc "consult-dir: switch directories easily in Emacs"
    :url "https://github.com/karthink/consult-dir"
    :tag "convenience"
    :leaf-autoload nil
    :leaf-defun nil
    :after consult selectrum
    :bind
    ("C-x C-d" . consult-dir)
    (:minibuffer-local-completion-map
     ("C-x C-d" . consult-dir)
     ("C-x C-j" . consult-dir-jump-file))
    (:selectrum-minibuffer-map
     ("C-x C-d" . consult-dir)
     ("C-x C-j" . consult-dir-jump-file))
    :init (sup 'consult-dir))
#+end_src


** Dired                                                         :files:

DiredMode is the mode of a Dired buffer.  It shows a directory (folder) listing
that you can use to perform various operations on files and subdirectories in
the directory. The operations you can perform are numerous, from creating
subdirectories to byte-compiling files, searching files, and of course visiting
(editing) files.

https://www.emacswiki.org/emacs/DiredMode

#+begin_src emacs-lisp
  (n/leaf-nv dired
    :doc "DiredMode is the mode of a Dired buffer."
    :url "https://www.emacswiki.org/emacs/DiredMode"
    :tag "files"
    :leaf-autoload nil
    :leaf-defun nil
    :bind
    (:dired-mode-map
     ([mouse-2] . dired-find-file)
     ("C-c C-p" . wdired-change-to-wdired-mode))
    :custom
    `(insert-directory-program . ,(or (executable-find "gls")
                                     (executable-find "ls")))
    (dired-recursive-deletes  . 'top))
#+end_src

** Easy Kill                                       :killing:convenience:

Provide commands easy-kill and easy-mark to let users kill or mark things easily.

https://github.com/leoliu/easy-kill

#+begin_src emacs-lisp
  (n/leaf-nv easy-kill
    :doc "Kill & Mark Things Easily in Emacs."
    :url "https://github.com/leoliu/easy-kill"
    :tag "killing" "convenience"
    :leaf-autoload nil
    :leaf-defun nil
    :init (sup 'easy-kill)
    :bind (([remap kill-ring-save] . easy-kill)
           ([remap mark-sexp]      . easy-mark)))
#+end_src

** Emacs Spatial Navigate                                      :editing:

Spatial navigation in Emacs.

https://gitlab.com/ideasman42/emacs-spatial-navigate

#+begin_src emacs-lisp
  (n/leaf-nv spatial-navigate
    :doc "Spatial navigation in Emacs."
    :url "https://gitlab.com/ideasman42/emacs-spatial-navigate"
    :tag "editing"
    :leaf-autoload nil
    :leaf-defun nil
    :bind (("<C-p>" . spatial-navigate-backward-vertical-bar)
           ("<C-n>" . spatial-navigate-forward-vertical-bar)
           ("<M-b>" . spatial-navigate-backward-horizontal-bar)
           ("<M-f>" . spatial-navigate-forward-horizontal-bar)
           ("<M-up>" . spatial-navigate-backward-vertical-box)
           ("<M-down>" . spatial-navigate-forward-vertical-box)
           ("<H-left>" . spatial-navigate-backward-horizontal-box)
           ("<H-right>" . spatial-navigate-forward-horizontal-box))
    :init (sup 'spatial-navigate))
#+end_src

** embark                                                  :convenience:

Emacs Mini-Buffer Actions Rooted in Keymaps.

https://github.com/oantolin/embark/

#+begin_src emacs-lisp
  (defun refresh-selectrum ()
    (setq selectrum--previous-input-string nil))


  (defun nasy/-resize-embark-collect-window (&rest _)
    "Automatically resizing auto-updating Embark Collect buffers to fit their contents."
    (when (memq embark-collect--kind '(:live :completions))
      (fit-window-to-buffer (get-buffer-window)
                            (floor (frame-height) 2) 1)))

  (defun shrink-selectrum ()
    "Shrink Selectrum to a single line while using embark-collect-live."
    (when (eq embark-collect--kind :live)
      (with-selected-window (active-minibuffer-window)
        (setq-local selectrum-num-candidates-displayed 1)
        (setq-local selectrum-display-style
                    '(horizontal :before-candidates "[" :after-candidates "]"
                                 :more-candidates "" :candidates-separator "")))))

  (n/leaf-nr embark
    :doc "Emacs Mini-Buffer Actions Rooted in Keymaps."
    :url "https://github.com/oantolin/embark"
    :tag "convenience"
    :leaf-autoload nil
    :leaf-defun nil
    :after selectrum
    :require t
    :bind
    ([remap describe-bindings] . embark-bindings)
    (:embark-file-map
     ("s" . sudo-edit))
    (:selectrum-minibuffer-map
     ("M-o" . embark-act))
    (:nasy/active-region-map
     :package 風雨旹用
     ("M-o" . embark-act))

    :custom
    ((embark-action-indicator
      . (lambda (map &optional _target)
          (which-key--show-keymap "Embark" map nil nil 'no-paging)
          #'which-key--hide-popup-ignore-command))
     (embark-become-indicator
      . embark-action-indicator))

    :hook
    ;; icomplete
    ;; (embark-pre-action-hook . completion--flush-all-sorted-completions)
    ;; selectrum
    (embark-pre-action-hook   . refresh-selectrum)
    (embark-collect-mode-hook . shrink-selectrum)
    ;; Embark Collect
    (embark-post-action-hook . embark-collect--update-linked)

    ;; misc
    (embark-collect-post-revert-hook . nasy/-resize-embark-collect-window)

    :init (sup 'embark))
#+end_src

** Flycheck                                :convenience:languages:tools:

Modern on-the-fly syntax checking extension for GNU Emacs.

[[https://www.flycheck.org/][flycheck.org]]

https://github.com/flycheck/flycheck

#+begin_src emacs-lisp
  (n/leaf-nv flycheck
    :doc "On the fly syntax checking for GNU Emacs."
    :url "https://github.com/flycheck/flycheck"
    :tag "convenience" "languages" "tools"
    :hook prog-mode-hook
    :custom
    (flycheck-display-errors-function
     . #'flycheck-display-error-messages-unless-error-list)
    (flycheck-check-syntax-automatically . '(save idle-change mode-enabled))
    (flycheck-display-errors-delay       . 0.25)
    :bind
    (:flycheck-error-list-mode-map
     ("C-n" . flycheck-error-list-next-error)
     ("C-p" . flycheck-error-list-previous-error)
     ("RET" . flycheck-error-list-goto-error)
     ([return] . flycheck-error-list-goto-error))
    :init (sup 'flycheck)
    :defer-config
    (defalias 'show-error-at-point-soon
      'flycheck-show-error-at-point)
    (add-to-list 'flycheck-emacs-lisp-checkdoc-variables 'sentence-end-double-space))
#+end_src

** Grep                                                        :builtin:

#+begin_src emacs-lisp
  (n/leaf-nv grep
    :tag "builtin"
    :custom
    ((grep-highlight-matches grep-scroll-output) . t))
#+end_src

** Helpful                                                   :help:lisp:

A better Emacs *help* buffer.

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
  (n/leaf-nv helpful
    :doc "A better Emacs *help* buffer."
    :url "https://github.com/Wilfred/helpful"
    :tag "help" "lisp"
    :bind (("C-c d" . helpful-at-point)
           ([remap describe-function]   . helpful-callable)
           ([remap describe-variable]   . helpful-variable)
           ([remap describe-key]        . helpful-key))
    :init (sup 'helpful))
#+end_src

** marginalia                                               :extensions:

marginalia.el - Marginalia in the minibuffer

https://github.com/minad/marginalia

#+begin_src emacs-lisp
  (n/leaf marginalia
    :doc "marginalia.el - Marginalia in the minibuffer."
    :url "https://github.com/minad/marginalia"
    :tag "extensions"
    :after selectrum
    :bind (:minibuffer-local-map
           ("M-a" . marginalia-cycle))
    :init
    (sup 'marginalia)
    (marginalia-mode 1)
    :advice (:after marginalia-cycle
                    (lambda ()
                      (when (bound-and-true-p selectrum-mode)
                        (selectrum-exhibit)))))
#+end_src

** Orderless                                                :extensions:

This package provides an orderless completion style that divides the
pattern into space-separated components, and matches candidates that
match all of the components in any order. Each component can match in
any one of several ways: literally, as a regexp, as an initialism, in
the flex style, or as multiple word prefixes. By default, regexp and
literal matches are enabled.

https://github.com/oantolin/orderless

#+begin_src emacs-lisp
  (n/leaf-nv orderless
    :doc "Emacs completion style that matches multiple regexps in any order."
    :url "https://github.com/oantolin/orderless"
    :tag "extensions"
    :commands (n/first-initialism n/flex-if-twiddle
               n/strict-if-hash n/without-if-bang)
    :custom
    (completion-styles . '(orderless))
    (orderless-skip-highlighting . (lambda () selectrum-is-active))
    (orderless-matching-styles
     . '(orderless-regexp
         orderless-initialism
         orderless-literal))
    (selectrum-highlight-candidates-function . #'orderless-highlight-matches)
    (orderless-style-dispatchers   . '(nasy/-orderless-dispatch))
    (orderless-component-separator . "[ &]")
    (completion-category-overrides . '((file (styles . (partial-completion)))))

    :init
    (sup 'orderless))


  (defun nasy/-orderless-dispatch (pattern _index _total)
    "Orderless (PATTERN) dispatch.

  Recognizes the following patterns:
  ,* ~flex flex~
  ,* =literal literal=
  ,* `initialism initialism`
  ,* !without-literal without-literal!
  ,* .ext (file extension)
  ,* regexp$ (regexp matching at end)"
    (cond
     ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
     ((string-suffix-p "$" pattern) `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
     ;; File extensions
     ((string-match-p "\\`\\.." pattern) `(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x100000-\x10FFFD]*$")))
     ;; Ignore single !
     ((string= "!" pattern) `(orderless-literal . ""))
     ;; Without literal
     ((string-prefix-p "!" pattern) `(orderless-without-literal . ,(substring pattern 1)))
     ((string-suffix-p "!" pattern) `(orderless-without-literal . ,(substring pattern 0 -1)))
     ;; Initialism matching
     ((string-prefix-p "`" pattern) `(orderless-initialism . ,(substring pattern 1)))
     ((string-suffix-p "`" pattern) `(orderless-initialism . ,(substring pattern 0 -1)))
     ;; Literal matching
     ((string-prefix-p "=" pattern) `(orderless-literal . ,(substring pattern 1)))
     ((string-suffix-p "=" pattern) `(orderless-literal . ,(substring pattern 0 -1)))
     ;; Flex matching
     ((string-prefix-p "~" pattern) `(orderless-flex . ,(substring pattern 1)))
     ((string-suffix-p "~" pattern) `(orderless-flex . ,(substring pattern 0 -1)))))
#+end_src

** Page Break Lines                                  :convenience:faces:

This Emacs library provides a global mode which displays ugly form feed
characters as tidy horizontal rules.

https://github.com/purcell/page-break-lines

#+begin_src emacs-lisp
  (n/leaf-nv page-break-lines
    :doc "Emacs: display ugly ^L page breaks as tidy horizontal lines"
    :url "https://github.com/purcell/page-break-lines"
    :tag "convenience" "faces"
    :hook
    (nasy-first-key-hook . global-page-break-lines-mode)
    (nasy/font-change-hook
     . (lambda ()
         (progn
           (nasy/change-char-width page-break-lines-char 2)
           (nasy/set-symbol ?⊸ 18 nil))))
    :custom
    (page-break-lines-char . ?⊸)
    :init (sup 'page-break-lines))
#+end_src

** Parens                               :faces:languages:parens:builtin:

#+begin_src emacs-lisp
  (n/leaf-nv paren
    :tag "builtin"
    :hook (nasy-first-key-hook . show-paren-mode))
#+end_src

** Projectile                                      :convenience:project:

Projectile is a project interaction library for Emacs. Its goal is to provide a
nice set of features operating on a project level without introducing external
dependencies (when feasible). For instance - finding project files has a
portable implementation written in pure Emacs Lisp without the use of GNU find
(but for performance sake an indexing mechanism backed by external commands
exists as well).

https://github.com/bbatsov/projectile

#+begin_src emacs-lisp
  (n/leaf-nv projectile
    :doc "Projectile is a project interaction library for Emacs."
    :url "https://github.com/bbatsov/projectile"
    :tag "project" "convenience"
    :bind ([remap find-tag] . projectile-find-tag)
    :custom
    `(projectile-known-projects-file . ,(concat *nasy-var* "projectile/known-projects.el"))
    (projectile-indexing-method          . 'hybrid)
    (projectile-require-project-root     . 'prompt)
    (projectile-ignored-project-function . #'nasy/p-ignore-p)
    :init (sup 'projectile)
    :config
    (setq projectile-project-root-files-top-down-recurring
           (append '("compile_commands.json"
                     ".cquery")
                   projectile-project-root-files-top-down-recurring)))
#+end_src

** Recentf                                                       :files:

Recentf is a minor mode that builds a list of recently opened files.

https://www.emacswiki.org/emacs/RecentFiles

#+begin_src emacs-lisp
  (defvar nasy--recentf-cleaned nil)

  (n/leaf-nv recentf
    :doc "Recentf is a minor mode that builds a list of recently opened files."
    :url "https://www.emacswiki.org/emacs/RecentFiles"
    :tag "files"
    :bind ("C-c r" . recentf-open-files)
    :hook nasy-first-key-hook
    :mode-hook
    (after-x '風雨旹用
      (unless nasy--recentf-cleaned
        (setq nasy--recentf-cleaned t)
        (recentf-cleanup)))
    :custom
    `(recentf-save-file . ,(concat *nasy-var* "recentf-save.el"))
    (recentf-filename-handlers
     . '(;; Text properties inflate the size of recentf's files, and there is
         ;; no purpose in persisting them, so we strip them out.
         substring-no-properties
         ;; Resolve symlinks of local files. Otherwise we get duplicate
         ;; entries opening symlinks.
         nasy/file-truename
         ;; Keep some symlinks
         nasy/file-sym-t
         ;; Replace $HOME with ~, which is more portable, and reduces how much
         ;; horizontal space the recentf listing uses to list recent files.
         abbreviate-file-name))
    (recentf-auto-cleanup    . 'never)
    (recentf-max-saved-items . 100)
    (recentf-exclude
     . `(,(abbreviate-file-name
           (locate-user-emacs-file *nasy-etc*))
         ,(abbreviate-file-name
           (locate-user-emacs-file *nasy-var*))
         "/tmp/" "/ssh:" "/nix/store" "~/.nix/store" ,(locate-user-emacs-file "straight"))))
#+end_src

** Savehist                                                    :history:

#+begin_src emacs-lisp
  (n/leaf-nv savehist
    :hook emacs-startup-hook
    :custom
    (kill-ring-max              . 300)
    (history-length             . 3000)
    (history-delete-duplicates  . t)
    (savehist-autosave-interval . 3600)
    `(savehist-file
      . ,(concat *nasy-var* "savehist.el"))
    (savehist-additional-variables
     . '(mark-ring
         global-mark-ring
         search-ring
         regexp-search-ring
         extended-command-history)))
#+end_src

** Selectrum                                                :extensions:

Better solution for incremental narrowing in Emacs.

https://github.com/raxod502/selectrum

#+begin_src emacs-lisp
  (n/leaf-nv selectrum
    :doc "Better solution for incremental narrowing in Emacs."
    :url "https://github.com/raxod502/selectrum"
    :tag "extensions"
    :hook
    (nasy-first-key-hook)
    (nasy--defer-load-hook . (lambda () (require 'selectrum)))
    :mode-hook
    (after-x '風雨旹用
      (nasy/active-region-mode 1))
    :init
    (sup 'selectrum))
#+end_src

** Sessions                                                    :history:

#+begin_src emacs-lisp
  (n/leaf-nv session
    :hook
    (nasy-first-key-hook . session-initialize)
    (after-save-hook     . session-save-session)
    :custom
    `(session-save-file              . ,(concat *nasy-var* "session"))
    (session-name-disable-regexp     . "\\(?:\\`'/tmp\\|\\.git/[A-Z_]+\\'\\)")
    (session-save-file-coding-system . 'utf-8)
    (desktop-globals-to-save
     . '((comint-input-ring        . 50)
         (compile-history          . 30)
         desktop-missing-file-warning
         (dired-regexp-history     . 20)
         (extended-command-history . 30)
         (face-name-history        . 20)
         (file-name-history        . 100)
         (grep-find-history        . 30)
         (grep-history             . 30)
         (ivy-history              . 100)
         (magit-revision-history   . 50)
         (minibuffer-history       . 50)
         (org-clock-history        . 50)
         (org-refile-history       . 50)
         (org-tags-history         . 50)
         (query-replace-history    . 60)
         (read-expression-history  . 60)
         (regexp-history           . 60)
         (regexp-search-ring       . 20)
         register-alist
         (search-ring              . 20)
         (shell-command-history    . 50)
         tags-file-name
         tags-table-list
         kill-ring))
    :init (sup 'session))
#+end_src

** Subword                                                     :builtin:

#+begin_src emacs-lisp
  (n/leaf-nv subword
    :tag "builtin"
    :hook prog-mode-hook)
#+end_src

** switch-window                                           :convenience:

Offer a *visual* way to choose a window to switch to.

https://github.com/dimitri/switch-window

#+begin_src emacs-lisp
  (n/leaf-nv switch-window
    :doc "Offer a *visual* way to choose a window to switch to."
    :url "https://github.com/dimitri/switch-window"
    :tag "convenience"
    :leaf-autoload nil
    :leaf-defun nil
    :after transient
    :bind
    ("C-c o" . transient-dwim--nasy/switch-window)
    ("C-c 1" . toggle-delete-other-windows)
    ("C-c 2" . split-window--v)
    ("C-c 3" . split-window--h)
    ("C-x |" . split-window-horizontally-instead)
    ("C-x _" . split-window-vertically-instead)
    ("C-x o" . other-window)
    ("C-c x" . nasy/split-window)
    ("M-o"   . switch-window)
    :custom
    (switch-window-shortcut-style . 'alphabet)
    (switch-window-timeout        . nil)
    :hook (nasy--defer-load-hook . (lambda () (require 'switch-window)))
    :transient
    (transient-dwim--nasy/switch-window nil
      "Transient-dwim for `switch-window'."
      [["Switch Window"
        ("o" "Other window" other-window)
        ("s" "Switch mindow" switch-window)
        ("1" "Delete other window" toggle-delete-other-windows)
        ("r" "Split window right" split-window-right)
        ("b" "Split window below" split-window-below)
        ("|" "Split window horizontally" split-window-horizontally-instead)
        ("_" "Split window vertically" split-window-vertically-instead)
        ("x" "Split window show recently" nasy/split-window)]])
    :init (sup 'switch-window))
#+end_src

** Tempo                                                       :builtin:

#+begin_src emacs-lisp
  (n/leaf-nv tempo
    :tag "builtin"
    :commands tempo-define-template)
#+end_src

** transient                                                  :bindings:

Taking inspiration from prefix keys and prefix arguments, Transient
implements a similar abstraction involving a prefix command, infix
arguments and suffix commands. We could call this abstraction a
"transient command", but because it always involves at least two
commands (a prefix and a suffix) we prefer to call it just a
"transient".

https://magit.vc/manual/transient

https://github.com/magit/transient

#+begin_src emacs-lisp
  (leaf transient
    :doc "Transient commands."
    :url "https://github.com/magit/transient"
    :tag "bindings"
    :custom
    `((transient-history-file . ,(concat *nasy-var* "transient/history.el"))
      (transient-levels-file  . ,(concat *nasy-etc* "transient/levels.el"))
      (transient-values-file  . ,(concat *nasy-etc* "transient/values.el")))
    :hook (nasy--defer-load-hook . (lambda () (require 'transient)))
    :init (add-to-list 'nasy--defer-loads 'transient))
#+end_src

** Unfill                                                  :convenience:

Functions providing the inverse of Emacs' fill-paragraph and fill-region

https://github.com/purcell/unfill

#+begin_src emacs-lisp
  (n/leaf-nv unfill
    :doc "Functions providing the inverse of Emacs' fill-paragraph and fill-region"
    :url "https://github.com/purcell/unfill"
    :tag "convenience"
    :bind (("M-q" . unfill-toggle))
    :init (sup 'unfill))
#+end_src

** Uniquify                                              :builtin:files:

#+begin_src emacs-lisp
  (n/leaf-nv uniquify
    :tag "builtin" "files"
    :custom
    (uniquify-buffer-name-style   . 'reverse)
    (uniquify-separator           . " • ")
    (uniquify-after-kill-buffer-p . t)
    (uniquify-ignore-buffers-re   . "^\\*"))
#+end_src

** View Large File                          :files:largefiles:utilities:

Emacs minor mode that allows viewing, editing, searching and comparing large
files in batches, trading memory for processor time.

https://github.com/m00natic/vlfi

#+begin_src emacs-lisp
  (n/leaf-nv vlf
    :doc "View Large Files in Emacs"
    :url "https://github.com/m00natic/vlfi"
    :tag "files" "large files" "utilities"
    :commands ffap-vlf
    :init
    (sup 'vlf)
    (defun ffap-vlf ()
      "Find file at point with VLF."
      (interactive)
      (let ((file (ffap-file-at-point)))
        (unless (file-exists-p file)
          (error "File does not exist: %s" file))
        (vlf file))))
#+end_src

** Which Function                                              :builtin:

#+begin_src emacs-lisp
  (n/leaf-nv which-func
    :tag "builtin"
    :hook (nasy-first-key-hook . which-function-mode))
#+end_src

** Whitespace                                      :convenience:data:wp:

Visualize blanks (TAB, (HARD) SPACE and NEWLINE).

https://www.emacswiki.org/emacs/WhiteSpace

In Emacs, intelligently call whitespace-cleanup on save.

https://github.com/purcell/whitespace-cleanup-mode

#+begin_src emacs-lisp
  (n/leaf-nv whitespace
    :tag "data" "wp"
    :init
    (defun no-trailing-whitespace ()
      "Turn off display of trailing whitespace in this buffer."
      (setq show-trailing-whitespace nil))
    :hook
    ;; But don't show trailing whitespace in SQLi, inf-ruby etc.
    ((artist-mode-hook
      picture-mode-hook
      special-mode-hook
      Info-mode-hook
      eww-mode-hook
      term-mode-hook
      vterm-mode-hook
      comint-mode-hook
      compilation-mode-hook
      twittering-mode-hook
      minibuffer-setup-hook
      fundamental-mode) . no-trailing-whitespace))

  (n/leaf-nv whitespace-cleanup-mode
    :doc "In Emacs, intelligently call whitespace-cleanup on save."
    :url "https://github.com/purcell/whitespace-cleanup-mode"
    :tag "convonience"
    :custom
    (whitespace-cleanup-mode-only-if-initially-clean . nil)
    (whitespace-style
     . '(face trailing tabs spaces newline
              missing-newline-at-eof empty indentation
              space-after-tab space-before-tab
              space-mark tab-mark newline-mark))
    :hook (text-mode-hook prog-mode-hook)
    :bind (("<remap> <just-one-space>" . cycle-spacing))
    :init (sup 'whitespace-cleanup-mode))
#+end_src

* 結                                                           :noexport:

#+begin_src emacs-lisp :exports none
  (provide '緑衣)
  ;;; 緑衣.el ends here
#+end_src

# Local Variables:
# org-src-fontify-natively: nil
# End:
